# 패러다임의 불일치

***여기는 책의 내용 그대로 적은 부분이 많기 때문에 포스팅은 안올리는 것이 적합.***

여기서 말하는 패러다임의 불일치란 대표적으로 한 가지 의미가 있다.
데이터베이스 테이블과 객체지향의 객체의 괴리감이 존재한다는 것이다.

> 책 문구 인용
"예를 들어 객체가 단순하면 객체의 모든 속성 값을 꺼내서 파일이나 데이터베이스에 저장하면 되지만, 부모 객체를 상속받았거나, 다른 객체를 참조하고 있다면 객체의 상태를 저장하기는 쉽지 않다. "


**여기서 괴리감을 느낄 수 있는 부분**
> 책 문구 인용
> "관계형 데이터베이스는 데이터 중심으로 구조화되어 있고 , 집합적인 사고를 요구한다. 그리고 객체지향에서 이야기하는 추상화, 상속, 다형성 같은 개념이 없다. "

## 패러다임 불일치를 객체지향에서 봐라보자

1. 상속
   객체지향 언어 자바를 예를 들어서 설명을 하면 객체를 통해서 상속을 하는 과정은 간단할 수 있지만 데이터베이스 입장에서 릴레이션끼리 상속을 하는 것은 굉장히 어려운 일이다. dtype 이라는 데이터의 형태가 존재하는 것처럼 보인다.
   그렇지만 이를 쿼리로 조회를 하거나 다른 CUD 작업에서는 큰 어려움이 있다고 한다. 때문에 JPA 를 사용하게 되면 아래와 같이 간단하게 API를 통해 작업이 가능하다.

코드는 아래와 같이 간단한 예제라고 생각하면 된다.

    abstract class item {...}
    class album extends item {...}


jpa.persist(album);
이렇게 하면 JPA는 다음 sql을 싱행해서 객체를 item, alum 두 테이블을 나누어 저장한다.
insert into item ...
insert into table ...

Album 객체를 조회해보자.

	String albumId = "id00";
	jpa.find(Album.class, albumId);

⇒ select i.*, a.*
from item i
join ALBUM a ON i.item_id = a.item_id

2. 연관관계
   객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.

반면에 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연광된 테이블을 조회한다.

ex code

	@Getter
	class Member {
		Team team;
	}.... Team 클래스는 약식으로 있다고 생각을 하자 .


⭐️조금 어려운 문제도 있는데, 객체는 참조가 있는 방향으로만 조회할 수 있다.    
위에서 member.getTeam() 을 이용해서 member 에서 team 객체를 조회할 수 있다. 하지만

Team 객체에서는 member의 객체는 참조할 수 없다. 하지만

DB에서는 테이블의 외래키를 통해서 각자의 릴레이션 테이블에서 조회가 가능하다. ⭐️


***객체를 테이블에 맞춰 모델링***

**⭐️중점은 이러하다.⭐️
객체는 참조를 통해서 연관관계를 형성한다 ⇒ member.getTeam();
테이블의 경우는 외래키를 통해 연관관계를 형성한다 ⇒ team_id**

**이거를 테이블에 객체를 맞추거나 , 객체에 테이블을 맞추는 것은 객체지향적이지 못한것이다. 때문에 개발자가 중간에서 이를 변환시켜주는 역할을 해야하는 것이다.**

이를 해결하기 위해서 소스코드 레벨에서 수정을 할 수 있다. 의사코드로 간단하게 말을 한다면 조회, 수정하는 과정에서 team을 참조해서 참조된 객체의 id 값을 가져 온다면 테이블 구조에서도 조회 , 수정이 가능하도록 구현할 수 있는 것이다.

----- 여기서부터 시작 00000
3.



> Written with [StackEdit](https://stackedit.io/).